<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Xiaofeng's Blog | 无与伦比]]></title>
  <subtitle><![CDATA[Learning programming, i enjoy it.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xiaofeng.site/"/>
  <updated>2015-11-19T02:03:24.660Z</updated>
  <id>http://xiaofeng.site/</id>
  
  <author>
    <name><![CDATA[xiaofeng]]></name>
    <email><![CDATA[xiaofeng355@sina.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[关于Android Log小记]]></title>
    <link href="http://xiaofeng.site/2015/11/18/%E5%85%B3%E4%BA%8EAndroid-Log%E5%B0%8F%E8%AE%B0/undefined/"/>
    <id>http://xiaofeng.site/2015/11/18/关于Android-Log小记/undefined/</id>
    <published>2015-11-18T08:38:59.000Z</published>
    <updated>2015-11-19T02:03:24.660Z</updated>
    <content type="html"><![CDATA[<p>作为Android开发工程师，项目开发的过程中，日志的打印是必不可少的，通过这些日志我们可以很好分析程序运行的状况与正确性，可以使用的日志输出有哪种形式呢？发布release版本应该怎么屏蔽掉这些日志呢？<br><a id="more"></a></p>
<h3 id="日志形式">日志形式</h3><ul>
<li><strong>Java形式</strong><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="string">" log for test "</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个一般不提倡使用</p>
<ul>
<li><strong>Android Log</strong><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Log</span><span class="built_in">.</span>d(<span class="built_in">TAG</span>, <span class="string">" log for test "</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个是Android标准的日志输出类：android.util.Log</p>
<h3 id="TAG定义">TAG定义</h3><p>关于TAG的命名简单说一下，基本上有以下几种形式：</p>
<ul>
<li><strong>人名</strong> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Log</span>.<span class="literal">d</span>(<span class="string">"gogh"</span> <span class="string">" log for test "</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>与代码无关，无法定位日志的位置</p>
<ul>
<li><strong>类名</strong><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final <span class="type">String</span> <span class="keyword">TAG</span> <span class="title">= LogUtils</span>.class.getSimpleName();</span><br><span class="line">Log.d(<span class="operator">TAG</span>, <span class="string">" log for test "</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>经过混淆的类，类名会改变为a、b这种形式，相应的TAG值也会改变，同样无法定位相关代码域。</p>
<h3 id="TAG定义推荐">TAG定义推荐</h3><p>那么哪种形式的TAG定义相对来说比较规范呢？给大家推荐一种相对规范的定义形式：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Utils &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> TAG = <span class="string">"Utils"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> setText(<span class="keyword">String</span> <span class="built_in">text</span>)&#123;</span><br><span class="line">        Logger.d(TAG, <span class="string">" setText text = "</span> + <span class="built_in">text</span> );</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基本的规范是：</p>
<ul>
<li><strong>日志所在类</strong></li>
<li><strong>日志所在的方法</strong></li>
<li><strong>基本的信息</strong><br>这样的log是不是很好了就，对调试程序而言，比较直观，可读性不叫强，容易定位，关键是不会因为代码的混淆改变TAG的值。</li>
</ul>
<h3 id="屏蔽日志">屏蔽日志</h3><p>我们的开发分为很多个阶段，但最终还是要有一个release版本发布，就需要把日志输出屏蔽掉，这一步相信大家都接触过了，那么就简单分析一下这一步。</p>
<p>#####运行时屏蔽<br>这个应该是使用的最多的，那么何为运行时屏蔽呢？就是在我们自定义的log工具类中设置一个值来开关日志，例如：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Logger &#123;</span><br><span class="line"></span><br><span class="line">    private static final boolean ENABLE = "true;</span><br><span class="line">    </span><br><span class="line">    public static void <span class="literal">d</span>(String tag, String message)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ENABLE)&#123;</span><br><span class="line">            android.util.<span class="keyword">Log</span>.<span class="literal">d</span>(tag, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger.<span class="literal">d</span>(XXX, <span class="string">"VERSION = "</span> + Build.<span class="keyword">VERSION</span>.SDK_INT);</span><br></pre></td></tr></table></figure></p>
<p>编写代码的过程中我们可以使用Logger.d(xxx, xxx);的形式来打印日志，在发布打包时将ENABLE修改为false就可以关闭日志。程序在运行的过程中就不会显示日志，但是message部分的方法（Build.VERSION.SDK_INT）还是执行到了，稍后解释。</p>
<h5 id="编译期屏蔽">编译期屏蔽</h5><p>这个就很简单了，在打包发布的时候加入代码混淆，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-assumenosideeffects class com.gogh.Logger&#123;&#10;    public static *** i(...);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是为了为了防止还有使用原生log的日志输出，直接混淆原生的log类，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-assumenosideeffects class android.util.Log &#123;&#10;    public static *** v(...);&#10;    public static *** d(...);&#10;    public static *** i(...);&#10;    public static *** w(...);&#10;    public static *** e(...);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以达到平日日志输出的效果了</p>
<h3 id="对比描述">对比描述</h3><p>运行时屏蔽其实很好理解，log中的日志输出是通过一个值控制的，这个输出的操作是在值判断通过之后进行的，而方法的调用需要传递多个参数，参数的传递肯定是在判断之前发生的，所以参数中的字串的拼接是会执行到的，方法同样也会被调用到，只是你看不到日志输出而已</p>
<p>编译期就是在编译过程中，Proguard进行优化，发生了内联操作，将dumpDebugInfo的被调用的方法体实现提取到调用的地方。在log相关的调用做了处理，结果是这里没有任何关于Logger.d(xxx,xxx)的调用，但是字串的拼接还是存在的，只是没有了方法的调用，这个可以通过反编译看看相关的代码片段</p>
<h3 id="总结">总结</h3><p>理论上编译期屏蔽相对于运行期屏蔽更优</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为Android开发工程师，项目开发的过程中，日志的打印是必不可少的，通过这些日志我们可以很好分析程序运行的状况与正确性，可以使用的日志输出有哪种形式呢？发布release版本应该怎么屏蔽掉这些日志呢？<br>]]>
    
    </summary>
    
      <category term="Log" scheme="http://xiaofeng.site/tags/Log/"/>
    
      <category term="Android" scheme="http://xiaofeng.site/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决Android Studio中Terminal无法输入的问题]]></title>
    <link href="http://xiaofeng.site/2015/11/16/%E8%A7%A3%E5%86%B3Android-Studio%E4%B8%ADTerminal%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/undefined/"/>
    <id>http://xiaofeng.site/2015/11/16/解决Android-Studio中Terminal无法输入的问题/undefined/</id>
    <published>2015-11-16T02:14:09.000Z</published>
    <updated>2015-11-18T07:02:56.617Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述：">问题描述：</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Windows</span>系统下<span class="keyword">Android </span>Studio中的Terminal无法获取焦点，不能输入文字。</span><br></pre></td></tr></table></figure>
<h3 id="问题原因：">问题原因：</h3><p>这个是因为系统升级造成的不兼容问题，在Windows环境开发的朋友们估计早早的就升级Win10了吧，UI非<br>常的炫酷。然而AS中的Terminal使用的还是Windows中的cmd控制台，也就是位于<br>C:\Windows\System32\目录下的cmd.exe。Win10下的cmd相对于早期版本的cmd做了一些改进，导<br>致了这里描述的问题。</p>
<h3 id="解决方案：">解决方案：</h3><p>下面给出具体的操作步骤，有图有真相：</p>
<p>1、win+R组合键打开运行窗口，输入cmd ，点击OK</p>
<p><img src="http://7xod2d.com1.z0.glb.clouddn.com/cmd.png" alt="cmd窗口"></p>
<p>2、在出现的cmd窗口中，右键点击标题栏-&gt;Properties，出现如下窗口：</p>
<p><img src="http://7xod2d.com1.z0.glb.clouddn.com/settings.png" alt="Properties窗口"></p>
<p>3、勾选 Use legacy console（requires relaunch）即使用旧版控制台（需要重启生效），就这么简单的操作就可以解决问题了，赶快试试吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题描述：">问题描述：</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td c]]>
    </summary>
    
      <category term="Android Studio" scheme="http://xiaofeng.site/tags/Android-Studio/"/>
    
      <category term="Terminal" scheme="http://xiaofeng.site/tags/Terminal/"/>
    
      <category term="Android" scheme="http://xiaofeng.site/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单实现ButterKnife中的injectView的方案]]></title>
    <link href="http://xiaofeng.site/2015/11/13/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0ButterKnife%E4%B8%AD%E7%9A%84injectView%E7%9A%84%E6%96%B9%E6%A1%88/undefined/"/>
    <id>http://xiaofeng.site/2015/11/13/简单实现ButterKnife中的injectView的方案/undefined/</id>
    <published>2015-11-13T01:37:14.000Z</published>
    <updated>2015-11-18T07:03:27.728Z</updated>
    <content type="html"><![CDATA[<p>首先说这里面用的知识点，注解、反射。</p>
<p>Android中findViewById(int resId)接受一个int的id参数，即通过资源id就可以找到对应的View。通过注解(annotation),我们可以资源id声明在对应的field上面，通过Java的反射，遍历每个field，找到对应的id，就可以初始化这个field（即view）。</p>
<a id="more"></a>
<h2 id="1、注解声明">1、注解声明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 表示用在字段上</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">// 表示在生命周期是运行时</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">//注解类，实现findViewById功能</span><br><span class="line">public @interface FindView &#123;</span><br><span class="line">	int findViewByResId() default <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、反射注入">2、反射注入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz = this.getClass();</span><br><span class="line">// 获得Activity中声明的字段</span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">//遍历所有字段</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">// 是否有我们自定义的注解类标志</span><br><span class="line">  <span class="keyword">if</span> (field.isAnnotationPresent(FindView.class)) &#123;</span><br><span class="line">  	   FindView inject = field.getAnnotation(FindView.class);</span><br><span class="line">      int mId = inject.findViewByResId();</span><br><span class="line">      View view;</span><br><span class="line">      <span class="keyword">if</span> (mId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          view = findViewById(mId);</span><br><span class="line">          field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">          field.set(this, view);// 给我们要找的字段设置值</span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、测试">3、测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@FindView(findViewByResId = R.id.id_text)</span><br><span class="line">private TextView mText;</span><br></pre></td></tr></table></figure>
<p>总结：<br>是不是很简单，这算是一个入门，接下来大家可以好好利用这种原理，实现不一样的功能了。<br>个人觉得这个不是特别好，每次都要通过反射来初始化，大家还是结合自己的开发环境酌情使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先说这里面用的知识点，注解、反射。</p>
<p>Android中findViewById(int resId)接受一个int的id参数，即通过资源id就可以找到对应的View。通过注解(annotation),我们可以资源id声明在对应的field上面，通过Java的反射，遍历每个field，找到对应的id，就可以初始化这个field（即view）。</p>]]>
    
    </summary>
    
      <category term="ButterKnife" scheme="http://xiaofeng.site/tags/ButterKnife/"/>
    
      <category term="InjectView" scheme="http://xiaofeng.site/tags/InjectView/"/>
    
      <category term="annotation" scheme="http://xiaofeng.site/tags/annotation/"/>
    
      <category term="Android" scheme="http://xiaofeng.site/categories/Android/"/>
    
  </entry>
  
</feed>
